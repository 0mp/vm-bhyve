#!/bin/sh
#-------------------------------------------------------------------------+
# Copyright (C) 2015 Matt Churchyard (churchers@gmail.com)
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# list virtual machines
__vm_list(){
	local _name _guest _cpu _memory _run _vm _auto _num
	local _format="%-15s %-15s %-6s %-9s %-12s %-20s\n"

	printf "${_format}" "NAME" "GUEST" "CPU" "MEMORY" "AUTOSTART" "STATE"

	ls -1 "${vm_dir}" | \
	while read _name; do
		if [ -e "${vm_dir}/${_name}/${_name}.conf" ]; then
			__config_load "${vm_dir}/${_name}/${_name}.conf"

			_num=1
			_auto="No"
			_run=$(ps ax | grep " ${_name} [(]bhyve" |awk '{print $1}')
			_guest=$(__config_get guest)
			_cpu=$(__config_get cpu)
			_memory=$(__config_get memory)

			# see if bhyve running
			if [ -n "${_run}" ]; then
				_run="Running (${_run})"
			else
				_run="Stopped"
			fi

			# if no bhyve, look for bhyveload/grub-bhyve
			if [ "${_run}" = "Stopped" ]; then
				_run=$(ps ax |grep -E "[b]hyveload|[g]rub-bhyve" |grep -E "[ ]${_name}$" |awk '{print $1}')

				if [ -n "${_run}" ]; then
					_run="Bootloader"
				else
					_run="Stopped"
				fi
			fi

			for _vm in ${vm_list}; do
				[ "${_vm}" = "${_name}" ] && _auto="Yes [${_num}]"
				_num=$(($_num + 1))
			done

			printf "${_format}" "${_name}" "${_guest}" "${_cpu}" "${_memory}" "${_auto}" "${_run}"
		fi
	done
}

# create a new virtual machine
__vm_create(){
	local _name _template _opt _size _vmdir _disk _disk_dev _uuid _newline

	while getopts t:s: _opt ; do
		case $_opt in
			t)
				_template=${OPTARG}
				;;
			s)
				_size=${OPTARG}
				;;
			*)
				__usage
				;;
		esac
	done

	shift $((OPTIND - 1))
	_name=$1

	: ${_size:=20G}
	: ${_template:=default}

	[ ! -f "${vm_dir}/.templates/${_template}.conf" ] && \
		__err "unable to find template ${vm_dir}/.templates/${_template}.conf"

	# we need to get disk0 name and device type from the template
	_disk=$(sysrc -inqf "${vm_dir}/.templates/${_template}.conf" disk0_name)
	_disk_dev=$(sysrc -inqf "${vm_dir}/.templates/${_template}.conf" disk0_dev)
	[ -z "${_disk}" ] && __err "template is missing disk0_name specification"

	# get the directory to store our vm data in
	_vmdir="${vm_dir}/${_name}"
	[ -e "${_vmdir}" ] && __err "directory ${_vmdir} already exists"

	# if we're on zfs, make a new filesystem
	__zfs_make_dataset "${_name}"

	[ ! -d "${_vmdir}" ] && mkdir "${_vmdir}"
	[ ! -d "${_vmdir}" ] && __err "unable to create virtual machine directory ${_vmdir}"

	cp "${vm_dir}/.templates/${_template}.conf" "${_vmdir}/${_name}.conf"
	[ $? -ne 0 ] && __err "unable to copy template to virtual machine directory"

	# generate a uuid
	# jump through some hoops to make sure it gets its own line (but no gap)
	_uuid=$(uuidgen)
	_newline=$(tail -1 "${_vmdir}/${_name}.conf" | wc -l | tr -d " ")
	[ "${_newline}" -eq "0" ] && echo "" >> "${_vmdir}/${_name}.conf" 
	sysrc -inqf "${_vmdir}/${_name}.conf" "uuid=${_uuid}" >/dev/null 2>&1

	# create the disk
	case "${_disk_dev}" in 
		zvol)
			__zfs_make_zvol "${_name}/${_disk}" "${_size}"
			;;			
		sparse-zvol)
			__zfs_make_zvol "${_name}/${_disk}" "${_size}" "1"
			;;
		*)
			truncate -s "${_size}" "${_vmdir}/${_disk}"
			[ $? -ne 0 ] && __err "failed to create sparse file for disk image"
			;;
	esac
}

# add a device to an existing guest
__vm_add(){
	local _name _device _type _sopt _opt

	while getopts d:t:s: _opt; do
		case $_opt in
			d)
				_device=${OPTARG}
				;;
			t)
				_type=${OPTARG}
				;;
			s)
				_sopt=${OPTARG}
				;;
			*)
				__usage
				;;
		esac
	done

	shift $((OPTIND - 1))
	_name="$1"

	# check guest
	[ -z "${_name}" ] && __usage
	[ ! -e "${vm_dir}/${_name}/${_name}.conf" ] && __err "${_name} does not appear to be a valid virtual machine"

	case "${_device}" in
		disk)
			__vm_add_disk "${_name}" "${_type}" "${_sopt}"
			;;
		network)
			__vm_add_network "${_name}" "${_sopt}"
			;;
		*)
			__err "device must be one of the following: disk network"
			;;
	esac
}

# add a disk to guest
__vm_add_disk(){
	local _name="$1"
	local _device="$2"
	local _size="$3"
	local _num=0 _curr _diskname _newline _emulation

	: ${_device:=file}

	[ -z "${_size}" ] && __usage

	# get the last existing disk
	__config_load "${vm_dir}/${_name}/${_name}.conf"

	while [ 1 ]; do
		_curr=$(__config_get "disk${_num}_name")
		[ -z "${_curr}" ] && break
		_emulation=$(__config_get "disk${_num}_type")
		_num=$((_num + 1))
	done

	# create the disk first, then update config if no problems
	case "${_device}" in
		zvol)
			__zfs_make_zvol "${_name}/disk${_num}" "${_size}"
			_diskname="disk${_num}"
			;;
		sparse-zvol)
			__zfs_make_zvol "${_name}/disk${_num}" "${_size}" "1"
			_diskname="disk${_num}"
			;;
		file)
			truncate -s "${_size}" "${vm_dir}/${_name}/disk${_num}.img"
			[ $? -ne 0 ] && __err "failed to create sparse file for disk image"
			_diskname="disk${_num}.img"
			;;
		*)
			__err "device type must be one of the following: zvol sparse-zvol file"
			;;
	esac

	# update configuration
	# all newer guests should have a newline, but just in case of old guests,
	# make sure we have a newline at the end
	_newline=$(tail -1 "${vm_dir}/${_name}/${_name}.conf" | wc -l | tr -d " ")
	[ "${_newline}" -eq "0" ] && echo "" >> "${vm_dir}/${_name}/${_name}.conf"

	sysrc -inqf "${vm_dir}/${_name}/${_name}.conf" "disk${_num}_name=${_diskname}" >/dev/null 2>&1
	sysrc -inqf "${vm_dir}/${_name}/${_name}.conf" "disk${_num}_type=${_emulation}" >/dev/null 2>&1
	sysrc -inqf "${vm_dir}/${_name}/${_name}.conf" "disk${_num}_dev=${_device}" >/dev/null 2>&1
	[ $? -ne 0 ] && __err "disk image created but errors while updating guest configuration"
}

# add network interface to guest
__vm_add_network(){
	local _name="$1"
	local _switch="$2"
	local _num=0 _curr _emulation

	[ -z "${_switch}" ] && __usage

	__config_load "${vm_dir}/${_name}/${_name}.conf"

	while [ 1 ]; do
		_emulation="${_curr}"
		_curr=$(__config_get "network${_num}_type")
		[ -z "${_curr}" ] && break
		_num=$((_num + 1))
	done

	# handle no existing network
	: ${_emulation:=virtio-net}

	# update configuration
	# all newer guests should have a newline, but just in case of old guests,
	# make sure we have a newline at the end
	_newline=$(tail -1 "${vm_dir}/${_name}/${_name}.conf" | wc -l | tr -d " ")
	[ "${_newline}" -eq "0" ] && echo "" >> "${vm_dir}/${_name}/${_name}.conf"

	sysrc -inqf "${vm_dir}/${_name}/${_name}.conf" "network${_num}_type=${_emulation}" >/dev/null 2>&1
	sysrc -inqf "${vm_dir}/${_name}/${_name}.conf" "network${_num}_switch=${_switch}" >/dev/null 2>&1
	[ $? -ne 0 ] && __err "errors encountered while updating guest configuration"
}

# install os to a virtual machine
__vm_install(){
	local _name="$1"
	local _iso="$2"

	[ -z "${_name}" -o -z "${_iso}" ] && __usage

	# just run start with an iso
	__vm_start "$1" "$2"
}

# start all virtual machines listed in rc.conf:$vm_list
__vm_startall(){
	local _vm _done _conf

	[ -z "${vm_list}" ] && exit

	: ${vm_delay:=5}

	for _vm in ${vm_list}; do
		[ -n "${_done}" ] && sleep ${vm_delay}

		# check conf file just to make sure not an obvious typo in rc.conf
		# if the vm is not configured correctly __vm_start will exit
		# causing any further vms to not be started
		_conf="${vm_dir}/${_vm}/${_vm}.conf"

		if [ -f "${_conf}" ]; then
			echo "Starting ${_vm}..."
			__vm_start "${_vm}"
			_done=1
		fi
	done
}

# stop all bhyve instances
# note this will also stop instances not started by vm-bhyve
__vm_stopall(){
	local _pids=$(ps ax | grep "[(]bhyve)" | awk '{print $1}')

	echo "Shutting down all bhyve virtual machines"
	killall bhyve
	wait_for_pids ${_pids}
}

# start a virtual machine
__vm_start(){
	local _name="$1"
	local _iso="$2"
	local _conf _host
	local _memory _guest _disk

	_conf="${vm_dir}/${_name}/${_name}.conf"

	[ -z "${_name}" ] && __usage
	[ ! -f "${_conf}" ] && __err "${_name} does not seem to be a valid virtual machine"

	if [ -e "${vm_dir}/${_name}/run.lock" ]; then
		_host=$(head -n 1 "${vm_dir}/${_name}/run.lock")
		__err "${_name} appears to already be running on ${_host} (locked)"
	fi

	__config_load "${_conf}"

	# check basic settings before going into background mode
	_memory=$(__config_get memory)
	_guest=$(__config_get guest)
	_disk=$(__config_get disk0_name)

	[ -z "${_memory}" -o -z "${_guest}" -o -z "${_disk}" ] && \
		__err "incomplete virtual machine configuration"

	# run background process to actually start bhyve
	# this will run as long as vm is running, including restarting bhyve after guest reboot
	$0 _run "${_name}" "${_iso}" >/dev/null 2>&1 &
}

# stop vm
__vm_stop(){
	local _name="$1"
	local _pid

	[ -z "${_name}" ] && __usage
	[ ! -e "/dev/vmm/${_name}" ] && __err "${_name} doesn't appear to be a running virtual machine"

	_pid=$(ps ax | grep ": ${_name} [(]bhyve)" | awk '{print $1}')
	[ -z "${_pid}" ] && __err "unable to locate process id for this virtual machine"

	kill "${_pid}"
}

# force reset
__vm_reset(){
	local _name="$1"

	[ -z "${_name}" ] && __usage
	[ ! -e "/dev/vmm/${_name}" ] && __err "${_name} doesn't appear to be a running virtual machine"

	__confirm "Are you sure you want to forcefully reset this virtual machine" || exit 0
	bhyvectl --force-reset --vm=${_name}
}

# force poweroff
__vm_poweroff(){
	local _name="$1"

	[ -z "${_name}" ] && __usage
	[ ! -e "/dev/vmm/${_name}" ] && __err "${_name} doesn't appear to be a running virtual machine"

	__confirm "Are you sure you want to forcefully poweroff this virtual machine" || exit 0
	bhyvectl --force-poweroff --vm=${_name}
}

# destroy
__vm_destroy(){
	local _name="$1"

	[ -z "${_name}" ] && __usage
	[ ! -e "${vm_dir}/${_name}" ] && __err "${_name} doesn't appear to be a valid virtual machine"

	__confirm "Are you sure you want to completely remove this virtual machine" || exit 0
	__zfs_destroy_dataset "${_name}"
	[ -e "${vm_dir}/${_name}" ] && rm -R "${vm_dir}/${_name}"
}

# console
__vm_console(){
	local _name="$1"
	local _port="$2"
	local _console

	[ -z "${_name}" ] && __usage
	[ ! -e "/dev/vmm/${_name}" ] && __err "${_name} doesn't appear to be a running virtual machine"
	[ ! -e "${vm_dir}/${_name}/console" ] && __err "can't locate console data for ${_name}"

	# did user specify a com port?
	# if not, get first in the file (the first will also be the console used for loader)
	if [ -n "${_port}" ]; then
		_console=$(grep "${_port}=" "${vm_dir}/${_name}/console" | cut -d= -f2)
	else
		_console=$(head -n 1 "${vm_dir}/${_name}/console" | cut -d= -f2)
	fi

	[ -z "${_console}" ] && __err "unable to locate console device for this virtual machine"
	cu -l "${_console}"
}

# configure a machine (edit the configuration file)
__vm_configure(){
	local _name="$1"

	[ -z "${_name}" ] && __usage
	[ ! -e "${vm_dir}/${_name}/${_name}.conf" ] && \
		__err "cannot locate configuration file for virtual machine: ${_name}"

	$EDITOR "${vm_dir}/${_name}/${_name}.conf"
}

# list iso images or get a new one
__vm_iso(){
	local _url="$1"

	if [ -n "${_url}" ]; then
		fetch -o "${vm_dir}/.iso" "${_url}"
	else
		echo "FILENAME"
		ls -1 "${vm_dir}/.iso"
	fi
}
