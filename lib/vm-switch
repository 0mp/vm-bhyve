#!/bin/sh
#-------------------------------------------------------------------------+
# Copyright (C) 2016 Matt Churchyard (churchers@gmail.com)
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# create switches from rc list on init
# this should run once per boot to make sure switches from the
# configuration file have bridge interfaces. If any new switches are
# created, the create function takes care of setting them up
#
switch::init(){
    local _switchlist _switch _type

    switch::__migrate
    config::core_get "_switchlist" "switch_list"

    if [ -n "${_switchlist}" ]; then
        for _switch in ${_switchlist}; do
            # get the switch type
            config::core_get "_type" "type_${_switch}"

            case "${_type}" in
                vxlan)  switch::vxlan::init "${_switch}" ;;
                manual) switch::manual::init "${_switch}" ;;
                vale)   ;;
                *)      switch::standard::init "${_switch}" ;;
            esac
        done
    fi
}

# list switches configured
#
switch::list(){
    local _switchlist _switch _type
    local _id _format="%-15s %-10s %-11s %-9s %-12s %s\n"

    config::core_get "_switchlist" "switch_list"

    printf "${_format}" "NAME" "TYPE" "IDENT" "VLAN" "NAT" "PORTS"

    if [ -n "${_switchlist}" ]; then
        for _switch in ${_switchlist}; do
            # get the switch type
            config::core_get "_type" "type_${_switch}"

            case "${_type}" in
                vale)   switch::vale::show "${_switch}" "${_format}" ;;
                vxlan)  switch::vxlan::show "${_switch}" "${_format}" ;;
                manual) switch::manual::show "${_switch}" "${_format}" ;;
                *)      switch::standard::show "${_switch}" "${_format}" ;;
            esac
        done
    fi
}

# create a new virtual switch
#
# @param string _switch name of the switch to create
#
switch::create(){
    local _switch
    local _type="standard"
    local _list _curr _vlan _if _bridge

    # process options
    while getopts t:i:n:b: _opt; do
        case ${_opt} in
            t) _type="${OPTARG}" ;;
            i) _if="${OPTARG}" ;;
            n) _vlan="${OPTARG}" ;;
            b) _bridge="${OPTARG}" ;;
            *) util::usage ;;
        esac
    done

    shift $((OPTIND - 1))
    _switch="$1"

    # check for a valid switch name
    core::check_name "${_switch}" || util::err "invalid switch name - '${_name}'"

    # make sure it's not an existing name
    config::core_get "_list" "switch_list"

    for _curr in ${_list}; do
        [ "${_switch}" = "${_curr}" ] && util::err "switch ${_switch} already exists"
    done

    # check vlan number
    if [ -n "${_vlan}" ]; then
       echo "${_vlan}" | egrep -qs '^[0-9]{1,4}$'
       [ $? -ne 0 ] && util::err "invalid vlan number"
       [ ${_vlan} -ge 4095 ] && util::err "invalid vlan number"
    fi

    # check switch type
    case "${_type}" in
        standard) switch::standard::create "${_switch}" "${_if}" "${_vlan}" ;;
        manual)   switch::manual::create "${_switch}" "${_bridge}" ;;
        vale)     switch::vale::create "${_switch}" ;;
        vxlan)    switch::vxlan::create "${_switch}" "${_if}" "${_vlan}" ;;
        *)        util::err "invalid switch type - '${_type}'" ;;
    esac
}

# destroy a switch
# remove from configuration and unload any interfaces we created
#
# @param string _switch name of the switch to remove
#
switch::remove(){
    local _switch="$1"
    local _type

    [ -z "${_switch}" ] && util::usage

    # get the type of switch
    config::core_get "_type" "type_${_switch}"

    case "${_type}" in
        standard) switch::standard::remove "${_switch}" ;;
        manual)   switch::manual::remove "${_switch}" ;;
        vale)     switch::vale::remove "${_switch}" ;;
        vxlan)    switch::vxlan::remove "${_switch}" ;;
        *)        util::err "unable to remove switch of unknown type" ;;
    esac

    # remove all configuration if there's no error
    if [ $? -eq 0 ]; then
        config::core_remove "switch_list" "${_switch}"
        config::core_remove "ports_${_switch} vlan_${_switch} nat_${_switch} type_${_switch}"
    else
        util::err "failed to remove virtual switch"
    fi
}

# add a new interface to a switch
#
# @param string _switch name of the switch
# @param string _if the interface to add
#
switch::add_member(){
    local _switch="$1"
    local _if="$2"
    local _type

    [ -z "${_switch}" -o -z "${_if}" ] && util::usage

    # get the type of switch
    config::core_get "_type" "type_${_switch}"

    case "${_type}" in
        standard) switch::standard::add_member "${_switch}" "${_if}" ;;
        manual)   switch::manual::add_member "${_switch}" "${_if}" ;;
        vale)     switch::vale::add_member "${_switch}" "${_if}" ;;
        vxlan)    switch::vxlan::add_member "${_switch}" "${_if}" ;;
        *)        util::err "unable to configure switch of unknown type" ;;
    esac
}

# remove a member interface from a virtual switch
#
# @param string _switch name of the switch
# @param string _if the interface to remove
#
switch::remove_member(){
    local _switch="$1"
    local _if="$2"
    local _type

    [ -z "${_switch}" -o -z "${_if}" ] && util::usage

    # get the type of switch
    config::core_get "_type" "type_${_switch}"

    case "${_type}" in
        standard) switch::standard::remove_member "${_switch}" "${_if}" ;;
        manual)   switch::manual::remove_member "${_switch}" "${_if}" ;;
        vale)     switch::vale::remove_member "${_switch}" "${_if}" ;;
        vxlan)    switch::vxlan::remove_member "${_switch}" "${_if}" ;;
        *)        util::err "unable to configure switch of unknown type" ;;
    esac
}

# change the vlan number on a virtual switch
#
# @param string _switch name of the switch
# @param int _vlan the vlan number (0 to turn vlan off)
#
switch::vlan(){
    local _switch="$1"
    local _vlan="$2"
    local _id _type

    [ -z "${_switch}" -o -z "${_vlan}" ] && util::usage

    switch::id "_id" "${_switch}"
    switch::type "_type" "${_switch}"
    [ -z "${_id}" ] && util:err "unable to locate specified virtual switch"

    echo "${_vlan}" | egrep -qs '^[0-9]{1,4}$'
    [ $? -ne 0 ] && util::err "invalid vlan number"
    [ ${_vlan} -ge 4095 ] && util::err "invalid vlan number"

    case "${_type}" in
        standard) switch::standard::vlan "${_switch}" "${_vlan}" ;;
        manual)   switch::manual::vlan "${_switch}" "${_vlan}" ;;
        vale)     switch::vale::vlan "${_switch}" "${_vlan}" ;;
        vxlan)    switch::vxlan::vlan "${_switch}" "${_vlan}" ;;
        *)        util::err "unable to configure switch of unknown type" ;;
    esac
}

# enable or disable nat functionality on a virtual switch
#
# @param string _switch name of the switch
# @param string _nat on|off
#
switch::nat(){
    util::err "nat support is currently disabled"
}

# return the type for a switch
#
# @param string _var variable to put type into
# @param string _switch the switch name
#
switch::type(){
    local _var="$1"
    local _switch="$2"

    config::core_get "${_var}" "type_${_switch}"
}

# get the bridge id for a virtual switch
#
# @param string _var variable to put name into
# @param string _switch the name of the switch
#
switch::id(){
    local _var="$1"
    local _switch="$2"
    local _type

    # get switch type
    config::core_get "_type" "type_${_switch}"

    case "${_type}" in
        vale) switch::vale::id "${_var}" "${_switch}" ;;
        *)    switch::standard::id "${_var}" "${_switch}" ;;
    esac
}

# temporary function to migrate old switch configuration
# to new style. we need the "type_{name}" config option to
# be present for each switch, rather than the ugly way we 
# used to use vale_* or bridge_* to determine switch type
#
switch::__migrate(){
    local _list _switch _type _bridge _vale _update

    config::core_get "_list" "switch_list"

    for _switch in ${_list}; do
        config::core_get "_type" "type_${_switch}"
        [ -n "${_type}" ] && continue

        _type="standard"

        # try to determine switch type using old method
        config::core_get "_bridge" "bridge_${_switch}"
        config::core_get "_vale" "vale_${_switch}"

        # manually specified bridge interface?
        [ -n "${_bridge}" ] && _type="manual"

        # vale flag present?
        if util::checkyesno "${_vale}"; then
            config::core_remove "vale_${_switch}"
            _type="vale"
        fi

        config::core_set "type_${_switch}" "${_type}"
        _update="1"
    done

    # reload configuration
    [ -n "${_update}" ] && config::core_load
}
